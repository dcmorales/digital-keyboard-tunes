name: Create a Conventional Commit on PR Approval

on:
  pull_request:
    types: [labeled, edited]
    branches:
      - main
      - develop
  pull_request_review:
    types: [submitted]

  workflow_run:
    workflows: ['restrict-approved-label.yml'] # Ensure this runs after checking labels
    types:
      - completed

permissions:
  contents: write

jobs:
  create_commit:
    runs-on: ubuntu-latest
    env:
      PR_TITLE: ${{ github.event.pull_request.title }}
      IS_SYNC_MERGE: false
    if: |
      (contains(github.event.pull_request.labels.*.name, 'approved') ||
      github.event.review.state == 'approved')

    steps:
      - name: Determine if merge is between main and develop
        run: |
          if [[ ("${{ github.event.pull_request.base.ref }}" == "main" && "${{ github.event.pull_request.head.ref }}" == "develop") ||
                ("${{ github.event.pull_request.base.ref }}" == "develop" && "${{ github.event.pull_request.head.ref }}" == "main") ]]; then
            echo "IS_SYNC_MERGE=true" >> $GITHUB_ENV
          else
            echo "IS_SYNC_MERGE=false" >> $GITHUB_ENV
          fi

      - name: Skip commit creation if merge is between main and develop
        if: env.IS_SYNC_MERGE == 'true'
        run: echo "Skipping commit creation steps because this is a branch-sync merge between main and develop; a conventional commit is not needed."

      - name: Get code
        if: env.IS_SYNC_MERGE == 'false'
        uses: actions/checkout@v3

      - name: Validate PR title and assign commit headers
        if: env.IS_SYNC_MERGE == 'false'
        run: |
          # List of valid commit types
          VALID_TYPES=("build" "chore" "ci" "docs" "feat" "fix" "perf" "refactor" "style" "test")

          # Sanitize PR title by removing unwanted characters
          PR_TITLE=$(echo "$PR_TITLE" | sed 's/[^a-zA-Z0-9 :;().-]//g')

          # Split PR title into segments based on semicolons
          IFS=';' read -ra SEGMENTS <<< "$PR_TITLE"

          # Initialize variables for each category
          CLIENT_HEADER=""
          SERVER_HEADER=""
          GENERAL_HEADER=""

          # Validate and categorize each segment
          for SEGMENT in "${SEGMENTS[@]}"; do
            # Remove leading/trailing whitespace from each segment
            SEGMENT=$(echo "$SEGMENT" | xargs)

            # Check segment length is no longer than 100 characters
            MAX_LENGTH=100
            if [ ${#SEGMENT} -gt $MAX_LENGTH ]; then
              echo "Segment is too long: ${SEGMENT}"
              exit 1
            fi

            # Extract commit type and scope (e.g., feat:, fix(client):)
            for TYPE in "${VALID_TYPES[@]}"; do
              if [[ "$SEGMENT" =~ ^$TYPE(\(([^)]+)\))?: ]]; then
                SCOPE=${BASH_REMATCH[2]}

                if [ "$SCOPE" == "client" ] && [ -z "$CLIENT_HEADER" ]; then
                  # Client-specific commit
                  CLIENT_HEADER="$SEGMENT"
                elif [ "$SCOPE" == "server" ] && [ -z "$SERVER_HEADER" ]; then
                  # Server-specific commit
                  SERVER_HEADER="$SEGMENT"
                elif [ -z "$SCOPE" ] && [ -z "$GENERAL_HEADER" ]; then
                  # General commit (no scope)
                  GENERAL_HEADER="$SEGMENT"
                fi
                break
              fi
            done
          done

          # Validate that at least one valid commit header exists
          if [ -z "$GENERAL_HEADER" ] && [ -z "$CLIENT_HEADER" ] && [ -z "$SERVER_HEADER" ]; then
            echo "No valid conventional commit header found in PR title."
            exit 1
          fi

          echo "Client commit: $CLIENT_HEADER"
          echo "Server commit: $SERVER_HEADER"
          echo "General commit: $GENERAL_HEADER"

          # Export categorized commit headers to environment variables
          echo "CLIENT_HEADER=$CLIENT_HEADER" >> $GITHUB_ENV
          echo "SERVER_HEADER=$SERVER_HEADER" >> $GITHUB_ENV
          echo "GENERAL_HEADER=$GENERAL_HEADER" >> $GITHUB_ENV

      - name: Assign commit body and footer
        if: env.IS_SYNC_MERGE == 'false'
        run: |
          # Fetch the PR body
          PR_BODY=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }} | jq -r .body)

          # Extract commit body between start and end comment markers
          CLIENT_BODY=$(echo "$PR_BODY" | sed -n '/<!-- Start of client commit body -->/,/<!-- End of client commit body -->/p' | sed '1d;$d')
          SERVER_BODY=$(echo "$PR_BODY" | sed -n '/<!-- Start of server commit body -->/,/<!-- End of server commit body -->/p' | sed '1d;$d')
          GENERAL_BODY=$(echo "$PR_BODY" | sed -n '/<!-- Start of general commit body -->/,/<!-- End of general commit body -->/p' | sed '1d;$d')

          # Extract commit footer between start and end comment markers
          CLIENT_FOOTER=$(echo "$PR_BODY" | sed -n '/<!-- Start of client commit footer -->/,/<!-- End of client commit footer -->/p' | sed '1d;$d')
          SERVER_FOOTER=$(echo "$PR_BODY" | sed -n '/<!-- Start of server commit footer -->/,/<!-- End of server commit footer -->/p' | sed '1d;$d')
          GENERAL_FOOTER=$(echo "$PR_BODY" | sed -n '/<!-- Start of general commit footer -->/,/<!-- End of general commit footer -->/p' | sed '1d;$d')

          # Write outputs to environment files
          echo "client_body=$CLIENT_BODY" >> $GITHUB_ENV
          echo "server_body=$SERVER_BODY" >> $GITHUB_ENV
          echo "general_body=$GENERAL_BODY" >> $GITHUB_ENV
          echo "client_footer=$CLIENT_FOOTER" >> $GITHUB_ENV
          echo "server_footer=$SERVER_FOOTER" >> $GITHUB_ENV
          echo "general_footer=$GENERAL_FOOTER" >> $GITHUB_ENV

      - name: Construct commit messages
        if: env.IS_SYNC_MERGE == 'false'
        run: |
          # Concatenate segments between new lines to follow commit convention
          CLIENT_COMMIT_MESSAGE=$(printf "%s\n\n%s\n\n%s" "$CLIENT_HEADER" "$CLIENT_BODY" "$CLIENT_FOOTER" | sed '/^$/N;/^\n$/D')
          SERVER_COMMIT_MESSAGE=$(printf "%s\n\n%s\n\n%s" "$SERVER_HEADER" "$SERVER_BODY" "$SERVER_FOOTER" | sed '/^$/N;/^\n$/D')
          GENERAL_COMMIT_MESSAGE=$(printf "%s\n\n%s\n\n%s" "$GENERAL_HEADER" "$GENERAL_BODY" "$GENERAL_FOOTER" | sed '/^$/N;/^\n$/D')

          # Output the constructed commit messages
          echo "CLIENT_COMMIT_MESSAGE=$CLIENT_COMMIT_MESSAGE" >> $GITHUB_ENV
          echo "SERVER_COMMIT_MESSAGE=$SERVER_COMMIT_MESSAGE" >> $GITHUB_ENV
          echo "GENERAL_COMMIT_MESSAGE=$GENERAL_COMMIT_MESSAGE" >> $GITHUB_ENV

      - name: Check if the most recent commit matches PR title
        if: env.IS_SYNC_MERGE == 'false'
        id: check_commit
        run: |
          # Fetch the branch from origin and ensure it exists locally
          git fetch origin ${{ github.head_ref }}:refs/remotes/origin/${{ github.head_ref }}

          # Checkout the fetched branch
          git checkout ${{ github.head_ref }}

          # Get the most recent commit message
          LAST_COMMIT_MSG=$(git log -1 --pretty=%s)

          echo "Most recent commit message: $LAST_COMMIT_MSG"

          # Check if the PR title (sanitized) matches the most recent commit message
          if [[ "$LAST_COMMIT_MSG" == "$SANITIZED_PR_TITLE" ]]; then
            echo "match_found=true" >> $GITHUB_ENV
            echo "::set-output name=match_found::true"
            echo "A commit with the message '$SANITIZED_PR_TITLE' already exists in the commit history. Skipping commit creation."
            exit 0
          else
            echo "match_found=false" >> $GITHUB_ENV
            echo "::set-output name=match_found::false"
            echo "$LAST_COMMIT_MSG. No matching commit found. Proceeding to create a new commit."
          fi

      - name: Skip commit creation if match found
        if: env.IS_SYNC_MERGE == 'false' && steps.check_commit.outputs.match_found == 'true'
        run: echo "Skipping commit creation as a matching commit was found."

      - name: Create an empty commit
        if: env.IS_SYNC_MERGE == 'false' && steps.check_commit.outputs.match_found == 'false'
        run: |
          # Construct the commit message
          COMMIT_MSG="$SANITIZED_PR_TITLE"
          if [ -n "$BREAKING_CHANGES" ]; then
            COMMIT_MSG="${COMMIT_MSG}\n$BREAKING_CHANGES"
          fi

          echo "Commit message:"
          echo "$COMMIT_MSG"

          # Configure Git
          cd client
          git config --local user.name "GitHub Action"
          git config --local user.email "action@github.com"

          # Pull the latest changes before pushing
          git pull --rebase origin ${{ github.head_ref }} || echo "No changes to pull"

          # Create the empty commit
          git commit --allow-empty -m "$COMMIT_MSG"

          # Push the changes
          git push origin HEAD:${{ github.head_ref }}
